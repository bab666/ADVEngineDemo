# D:\Works\Godot\spelLDemo\resources\scenarios\demo_scenario.txt

@goto save_test


# カメラテスト
@bg room
@chara ai normal
@camera zoom:1.0 offset:0,0 rotation:0 time:0

ai: カメラ機能の拡張テストを開始します。

# --- Test 1: 回転 (Rotation) ---
ai: まずは「回転」のテストです。時計回りに15度傾きます。
@camera rotation:15 time:1000 wait!

ai: 戻ります。
@camera rotation:0 time:1000 wait!

# --- Test 2: Lazyモード (滑らかな上書き) ---
ai: 次に「lazy」オプションのテストです。
ai: まず、3秒かけてズームインします。その途中で別のコマンドを割り込ませます。
ai: lazyを指定しているので、現在の途中位置から滑らかに次の動作へ移行するはずです。

# 1. 3秒かけて2倍ズーム（開始）
@camera zoom:2.0 time:3000

# 2. 1秒だけ待つ（まだズームの途中）
@wait time=1000

# 3. lazy指定で割り込み（ここから滑らかに回転へ移行）
@camera rotation:10 lazy time:2000 wait!

ai: 滑らかに移行しましたか？（カクつきがないこと）
@camera zoom:1.0 rotation:0 time:1000 wait!

# --- Test 3: 通常モード (Lazyなし・カクつき確認) ---
ai: 比較のため「lazyなし（デフォルト）」で同じことをします。
ai: 割り込んだ瞬間、最初のズーム目標（2倍）までワープしてから次の動作が始まります。

# 1. 3秒かけて2倍ズーム（開始）
@camera zoom:2.0 time:3000

# 2. 1秒だけ待つ
@wait time=1000

# 3. lazyなしで割り込み（ここでカクっと動くはず）
@camera rotation:-10 time:2000 wait!

ai: 今度はワープ（カクつき）が発生しましたか？
@camera zoom:1.0 rotation:0 time:1000 wait!

# --- Test 4: Async修正確認 ---
ai: 最後に修正された「非同期ブロック」の確認です。
ai: 画面を揺らしながら文章を表示します。クリックで読み進めても揺れは止まりません。

@async
	@camera rotation:5 time:100 wait!
	@camera rotation:-5 time:100 wait!
	@camera rotation:5 time:100 wait!
	@camera rotation:-5 time:100 wait!
	@camera rotation:0 time:100 wait!
@end_async

ai: 揺れている間もテキストは進みます。
ai: 揺れ終わりましたか？

ai: テスト終了です。お疲れ様でした。

# 新機能テストシナリオ
# --- 非同期カメラ演出の開始 ---
# @async ブロックの中身は、メインの会話とは別のラインで実行されます。
# ブロック内での wait! は「ブロック内の次のコマンドを待たせる」意味になります。


ai: カメラを初期位置に設定。

@async
	# 1. 30秒かけて、顔のあたり（Y=-300）へ2倍ズーム
	# wait! があるので、この30秒が終わるまで次の「元に戻る」コマンドは実行されません
	@camera zoom:2.0 offset:0,-300 time:10000 wait!

	# 2. 30秒かけて、元の位置（中心）と倍率に戻る
	@camera zoom:1.0 offset:0,0 time:30000 wait!
@end_async

# --- ここからメインシナリオ ---
# 上記のカメラ演出が裏で走っている状態で、会話が始まります。

ai: 今、カメラがゆっくりとズームし始めました。
ai: 往復で合計60秒かかる長い演出ですが、こうして会話を進めることができます。

@chara ai smile
ai: カメラが寄ってきても、私はいつも通りです。

# プレイヤーが読む速度によりますが、まだズーム中かもしれません
ai: この機能を使えば、「遠くの爆発を見ながら逃げる会話」や、
ai: 「ゆっくり日が暮れていく中での告白」などが表現できますね。

# もし演出の終了を待ちたい場合は、任意のタイミングで @sync を入れます
ai: さて、演出を強制終了してみましょう。
@kill 

# ジャンプテストシナリオ

@bg room

ai: 次の行で停止します。選択肢が出る想定です。
@stop

# ジャンプテスト

start: こんにちは。ここからテストを開始します。
@jump .part2

# ここはスキップされるはず
error: このメッセージが表示されたらバグです。

# ラベル定義
#part2
ai: パート2にジャンプしました！
ai: 次はサブルーチンを呼び出します。
@call .sub_routine

ai: おかえりなさい！サブルーチンから戻ってきました。
ai: 次は別のファイルへ遷移します。
@jump demo_scene1.start

# サブルーチン定義
#sub_routine
alice: ここはサブルーチンの中です。
@wait time=1000
alice: 処理が終わったので戻ります。
@return

# 終了処理
#end_roll
ai: これで全てのテストが完了です。


# 1. 2000ms 待つテスト
ai: 今から2秒待ちます。
@wait time=2000
ai: 2秒経ちました。

# 2. キャラ表示のwait完全実装テスト
@chara ai normal pos:auto time=1500 wait=true
ai: フェードイン(1.5秒)が終わるのを待ってから、このテキストが表示されます。

# 3. wait_cancel テスト（シナリオ上では分かりにくいですが機能としては実装済み）
ai: 次は3秒待ちますが、内部でキャンセルされたら即座に進みます（テスト用）。
@wait time=3000
ai: 終了です。


# 背景設定
@bg room

# 同時表示テスト

# 1. 異なるキャラの同時表示
# IDが違うので、wait=false なら同時に出ます
@chara ai normal pos:500,900 wait=false
@chara alice normal pos:1400,900 wait=true
ai: 私とアリスちゃん、同時に表示されていますか？

# 2. 同じキャラの分身表示 (src指定)
@chara_hide ai
@chara_hide alice

# メインの ai
@chara ai angry pos:500,900
# 分身の ai (IDを変えて、srcでデータを指定)
@chara ai_clone smile src=ai pos:1400,900 scale=0.8 layer=2
ai: 右にいるのは、私の分身（ai_clone）です。
ai: IDを変えれば、同じキャラでも何人でも出せます。

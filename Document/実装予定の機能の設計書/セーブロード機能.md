承知しました。

前回の設計方針（ステートスナップショット方式）に基づき、以下の実装を行います。

1. **各マネージャーの改修**: 状態の保存(`save_state`)と復元(`load_state`)の実装。特に `CharacterDisplay` は「現在の表示状態」を記憶するように大きく改修します。
2. **`SaveManager` の作成**: ファイルI/Oとスロット管理（オートセーブ含む）。
3. **コマンドの実装**: `@autosave`, `@autoload` の作成と登録。

この構成なら、将来的に「セーブ画面を作って好きなスロットに保存」という機能も `SaveManager` を呼ぶだけで実現できます。

------

### 1. CharacterDisplay の改修

キャラクターの「現在の表示パラメータ」を辞書で管理するようにします。これがないと、ロードした瞬間にキャラクターが消えてしまいます。

**scripts/character_display.gd**

GDScript

```
@tool
extends Node2D
class_name CharacterDisplay

# キャラクター ID -> キャラクターノード
var characters: Dictionary = {}

# キャラクターデータキャッシュ
var character_data_cache: Dictionary = {}

# ★追加: 現在の表示状態を保持する辞書 (ID -> パラメータ辞書)
var active_character_states: Dictionary = {}

# ... (set_character_data_direct, get_character_data は変更なし) ...

func show_character_ex(char_id: String, expression: String, params: Dictionary) -> Tween:
	# ★追加: 状態を保存 (paramsは参照渡しされる可能性があるので複製しておく)
	var state_to_save = params.duplicate()
	state_to_save["id"] = char_id
	state_to_save["expression"] = expression
	active_character_states[char_id] = state_to_save
	
	# ... (以下、既存の処理) ...
	var source_id = params.get("source_id", char_id)
	
	var char_data = get_character_data(source_id)
	if not char_data:
		push_warning("CharacterDisplay: データが見つかりません ID=" + source_id)
		return null

	var char_node: Node2D
	if characters.has(char_id):
		char_node = characters[char_id]
	else:
		char_node = Node2D.new()
		char_node.name = char_id
		add_child(char_node)
		characters[char_id] = char_node
	
	var final_scale = params.get("scale") if params.get("scale") != null else char_data.portrait_scale
	var is_mirror = params.get("reflect") if params.has("reflect") else char_data.mirror
	var fade_time = params.get("time", 1000) / 1000.0
	var layer = params.get("layer", 1)
	
	var pos_mode = params.get("pos_mode", "manual")
	var pos_vec = params.get("pos", Vector3.ZERO)
	var target_pos = Vector2(pos_vec.x, pos_vec.y)
	
	if pos_mode == "auto":
		var viewport_size = get_viewport_rect().size
		target_pos = Vector2(viewport_size.x / 2, viewport_size.y)
	
	char_node.z_index = layer
	char_node.position = target_pos
	
	_update_sprites(char_node, char_data, expression)
	
	var scale_vec = Vector2(final_scale, final_scale)
	if is_mirror: scale_vec.x *= -1
	char_node.scale = scale_vec
	
	if char_node.visible and fade_time <= 0:
		char_node.modulate.a = 1.0
		return null
	
	if not char_node.visible:
		char_node.modulate.a = 0.0
		char_node.show()
	
	var tween = create_tween()
	tween.tween_property(char_node, "modulate:a", 1.0, fade_time)
	
	return tween

# ... (_update_sprites, _add_sprite, get_character_data は変更なし) ...

func hide_character(char_id: String):
	if characters.has(char_id):
		characters[char_id].hide()
		# ★追加: 表示状態からも削除
		if active_character_states.has(char_id):
			active_character_states.erase(char_id)

func clear_all():
	for n in characters.values(): n.queue_free()
	characters.clear()
	# ★追加: 状態クリア
	active_character_states.clear()

# --- ★新規追加: セーブ＆ロード用メソッド ---

func save_state() -> Dictionary:
	# 単純に現在の状態辞書を返す
	return active_character_states.duplicate(true)

func load_state(data: Dictionary) -> void:
	clear_all()
	
	# 保存されたキャラを一人ずつ復元
	for char_id in data.keys():
		var params = data[char_id]
		var expression = params.get("expression", "normal")
		
		# ロード時はフェードなし(time=0)で即時表示する
		params["time"] = 0
		
		# 再表示実行
		show_character_ex(char_id, expression, params)
```

------

### 2. Audio, Scenario, Game Managerの改修

**scripts/audio_manager.gd**

GDScript

```
# 末尾に追加
func save_state() -> Dictionary:
	return {
		"current_bgm": current_bgm,
		"bgm_volume": bgm_volume,
		"se_volume": se_volume,
		"is_playing": bgm_player.playing
	}

func load_state(data: Dictionary) -> void:
	# まず設定値を復元
	if data.has("bgm_volume"): set_bgm_volume(data.bgm_volume)
	if data.has("se_volume"): set_se_volume(data.se_volume)
	
	var bgm_file = data.get("current_bgm", "")
	var was_playing = data.get("is_playing", false)
	
	# BGM復帰
	if not bgm_file.is_empty() and was_playing:
		# 再生中だったBGMが、現在と違う場合、または停止中の場合に再生
		if current_bgm != bgm_file or not bgm_player.playing:
			play_bgm_ex(bgm_file, {"volume": 100, "fade_duration": 0.0, "restart": false})
	else:
		stop_bgm(0.0)
```

**scripts/scenario_manager.gd**

GDScript

```
# 末尾に追加
func save_state() -> Dictionary:
	return {
		"current_file": current_file_path,
		"current_line": current_line,
		"call_stack": call_stack.duplicate(true)
	}

func load_state(data: Dictionary) -> void:
	var file_path = data.get("current_file", "")
	var line_index = data.get("current_line", 0)
	var stack = data.get("call_stack", [])
	
	if not file_path.is_empty():
		# ファイルをロード（ラベル情報などを再構築）
		load_scenario(file_path)
		# 行数を復元
		current_line = line_index
		call_stack = stack
```

scripts/game_manager.gd

GameManagerは SaveManager の保持と、カメラ情報の保存を担当します。

GDScript

```
# プロパティ宣言部分に追加
var save_manager: SaveManager

# _ready() 内に追加
func _ready():
	# ... (既存の初期化) ...
	
	# SaveManagerの初期化
	save_manager = SaveManager.new()
	save_manager.game_manager = self # 循環参照になるが、親子関係なので許容、またはシグナルで疎結合にする
	add_child(save_manager)
	
	command_context["save_manager"] = save_manager # コマンドからアクセスできるように
	
	# ... (既存の処理) ...
```

GameManagerにメソッド追加

（scripts/game_manager.gd の末尾付近）

GDScript

```
# カメラ状態の保存
func get_camera_state() -> Dictionary:
	return {
		"position": {"x": camera.position.x, "y": camera.position.y},
		"zoom": {"x": camera.zoom.x, "y": camera.zoom.y},
		"rotation": camera.rotation_degrees
	}

func set_camera_state(data: Dictionary):
	if data.is_empty(): return
	
	var pos = data.get("position", {"x": 0, "y": 0})
	var zm = data.get("zoom", {"x": 1, "y": 1})
	var rot = data.get("rotation", 0.0)
	
	camera.position = Vector2(pos.x, pos.y)
	camera.zoom = Vector2(zm.x, zm.y)
	camera.rotation_degrees = rot
	
	# カメラコマンドの「lazy」動作用コンテキストも更新しておく
	command_context["camera_target_pos"] = camera.position
	command_context["camera_target_zoom"] = camera.zoom
	command_context["camera_target_rot"] = camera.rotation_degrees
	# アニメーション中はキャンセルさせる
	if command_context.get("current_tween"):
		var t = command_context.get("current_tween")
		if t and t.is_valid(): t.kill()
		command_context["current_tween"] = null
```

------

### 3. SaveManager の作成

**scripts/save_manager.gd** (新規作成)

GDScript

```
extends Node
class_name SaveManager

const SAVE_DIR = "user://saves/"
const AUTO_SAVE_SLOT = 0 # オートセーブ用のスロットID

var game_manager: Node # GameManagerから注入される

func _ready():
	if not DirAccess.dir_exists_absolute(SAVE_DIR):
		DirAccess.make_dir_absolute(SAVE_DIR)

func _get_save_path(slot: int) -> String:
	return SAVE_DIR + "save_%d.json" % slot

# セーブ実行
func save_game(slot: int = AUTO_SAVE_SLOT) -> bool:
	if not game_manager: 
		push_error("SaveManager: GameManager not linked")
		return false
	
	# 各システムの状態を収集
	var save_data = {
		"version": "1.0",
		"timestamp": Time.get_unix_time_from_system(),
		"date_str": Time.get_datetime_string_from_system(),
		
		# マネージャーごとの状態
		"scenario": game_manager.scenario_manager.save_state(),
		"audio": AudioManager.save_state(),
		"characters": game_manager.character_display.save_state(),
		"variables": game_manager.variables.duplicate(),
		"camera": game_manager.get_camera_state()
	}
	
	var path = _get_save_path(slot)
	var file = FileAccess.open(path, FileAccess.WRITE)
	if file:
		file.store_string(JSON.stringify(save_data, "\t"))
		file.close()
		print("Save Completed: Slot ", slot)
		return true
	else:
		push_error("Failed to open save file: " + path)
		return false

# ロード実行
func load_game(slot: int = AUTO_SAVE_SLOT) -> bool:
	if not game_manager: return false
	
	var path = _get_save_path(slot)
	if not FileAccess.file_exists(path):
		push_warning("Save file not found: " + path)
		return false
	
	var file = FileAccess.open(path, FileAccess.READ)
	var json = JSON.new()
	var err = json.parse(file.get_as_text())
	if err != OK:
		push_error("Save file corrupted")
		return false
		
	var data = json.data
	print("Load Started: Slot ", slot)
	
	# --- 状態復元 ---
	
	# 1. 変数とカメラ
	if data.has("variables"):
		game_manager.variables = data["variables"]
	if data.has("camera"):
		game_manager.set_camera_state(data["camera"])
		
	# 2. オーディオ
	if data.has("audio"):
		AudioManager.load_state(data["audio"])
		
	# 3. キャラクター
	if data.has("characters"):
		game_manager.character_display.load_state(data["characters"])
		
	# 4. シナリオ (最後に実行)
	if data.has("scenario"):
		# シナリオをロードし、行数をセット
		game_manager.scenario_manager.load_state(data["scenario"])
		
		# UIをリセット（テキストボックスを消すなど）
		game_manager.window_manager.hide_all_windows()
		
		# 再開
		# 少し待ってから実行することで、復元処理の競合を防ぐ
		await get_tree().create_timer(0.1).timeout
		if game_manager.scenario_manager.has_next():
			game_manager.scenario_manager.next_line()
			
	return true
```

------

### 4. コマンドの実装

**scripts/commands/autosave_command.gd** (新規作成)

GDScript

```
extends BaseCommand
class_name AutoSaveCommand

func get_command_name() -> String:
	return "autosave"

func get_description() -> String:
	return "現在の状態をオートセーブスロットに保存します。"

func execute(_params: Dictionary, context: Dictionary) -> void:
	var sm = context.get("save_manager")
	if sm:
		sm.save_game(0) # Slot 0 = AutoSave

func requires_wait() -> bool:
	return false
```

**scripts/commands/autoload_command.gd** (新規作成)

GDScript

```
extends BaseCommand
class_name AutoLoadCommand

func get_command_name() -> String:
	return "autoload"

func get_description() -> String:
	return "オートセーブスロットから状態をロードします。"

func execute(_params: Dictionary, context: Dictionary) -> void:
	var sm = context.get("save_manager")
	if sm:
		sm.load_game(0) # Slot 0

func requires_wait() -> bool:
	return true # ロードが入るので、この行の処理は実質ここで打ち切り
```

------

### 5. コマンドの登録

**scripts/command_registry.gd**

GDScript

```
# register_builtin_commands() 内に追加

	register_command(AutoSaveCommand.new())
	register_command(AutoLoadCommand.new())
```

------

### 確認手順

1. 上記すべてのファイルを修正・作成します。
2. シナリオファイルに以下のように記述してテストします。

Plaintext

```
@bg room
@chara ai normal
ai: ここでオートセーブします。
@autosave

ai: 服装を変えて、カメラを動かします。
@camera zoom:1.5 rotation:10 time:1000 wait!
@chara ai angry

ai: ここでオートロードします。（最初の状態に戻るはず）
@autoload

ai: ここは表示されないはずです。
```

これで、`@autosave` で「標準の立ち絵・カメラ初期位置」が保存され、その後の変更（ズーム・angry）が行われた後、`@autoload` によって「標準の立ち絵・カメラ初期位置」に戻り、セーブした行の**次の行**（`ai: 服装を変えて...`）から再開されるはずです。
# プレビュー表示されない問題のデバッグガイド

## 実施した修正

### 1. CharacterDisplay に直接データ注入メソッド追加
**ファイル**: `scripts/character_display.gd`

```gdscript
# エディタ用: 外部から直接CharacterDataを注入
func set_character_data_direct(char_data: CharacterData):
    if char_data and not char_data.character_id.is_empty():
        character_data_cache[char_data.character_id] = char_data
```

### 2. エディタパネルで直接データ注入を使用
**ファイル**: `addons/character_manager/character_editor_panel.gd`

`_update_preview()` メソッドで、show_character() 前に：
```gdscript
preview_display.set_character_data_direct(current_character)
```

### 3. layer_offsets の安全な取得
CharacterDisplay で `portrait_data.layer_offsets` にアクセスする際、存在チェックを追加。

---

## デバッグ手順

### ステップ1: コンソール確認

Godotエディタでキャラクターエディターを開き、表情を選択した際に以下が出力されるか確認：

```
表情選択: normal
プレビュー更新: alice / normal
```

### ステップ2: データが正しく読み込まれているか

エディタパネルの `_update_preview()` に以下を追加してデバッグ：

```gdscript
func _update_preview():
    if current_portrait_name.is_empty(): return
    
    print("=== DEBUG ===")
    print("Character ID: ", current_character.character_id)
    print("Portrait Name: ", current_portrait_name)
    print("Portraits: ", current_character.portraits.keys())
    
    var portrait = current_character.portraits.get(current_portrait_name)
    if portrait:
        print("Base Image: ", portrait.base_image)
        print("Layers: ", portrait.layers)
    
    preview_display.clear_all()
    preview_display.set_character_data_direct(current_character)
    preview_display.show_character(current_character.character_id, current_portrait_name, 960, 540)
```

### ステップ3: 画像パスの確認

`character_display.gd` の `_add_sprite_layer()` で：

```gdscript
func _add_sprite_layer(...):
    print("画像読み込み試行: ", image_path)
    if not ResourceLoader.exists(image_path):
        push_warning("画像が見つかりません: " + image_path)
        return null
    print("画像読み込み成功")
    ...
```

---

## よくある原因

### 1. CharacterData クラスが @tool で認識されない
**症状**: `get_character_data()` が null を返す

**解決策**: 
- `set_character_data_direct()` を使って直接注入（今回の修正）
- CharacterData に `@tool` をつける（非推奨）

### 2. SubViewport のレンダリング設定
**症状**: Node2D は存在するがプレビューに表示されない

**確認**:
```gdscript
# character_editor.tscn の SubViewport
render_target_update_mode = 4  # ALWAYS
```

### 3. Camera2D の位置
**症状**: キャラが画面外に配置されている

**確認**:
```
Camera2D position = (960, 540)
CharacterDisplay に追加される Node2D position も (960, 540)
```

### 4. 画像パスが間違っている
**症状**: ResourceLoader.exists() が false

**確認**:
- `res://` から始まる絶対パス
- 拡張子が正しい (.png, .jpg)
- ファイルが実際に存在する

---

## テスト手順

### 1. 最小限のテストデータ作成

```json
{
  "character_id": "test",
  "display_name": "テスト",
  "portraits": {
    "normal": {
      "name": "normal",
      "base_image": "res://resources/characters/alice_normal.png",
      "layers": {}
    }
  }
}
```

### 2. エディターで読み込み

1. キャラクターエディターを開く
2. Character ID に `test` を入力
3. 読み込みボタン（または手動で新規作成）
4. 表情を選択
5. プレビューに表示されるか確認

### 3. 段階的確認

**ベース画像のみ**:
- レイヤーなしで表示されるか

**レイヤー追加**:
- eyebrows だけ追加して表示されるか

---

## 即座に試せる修正

### character_editor_panel.gd に追加

```gdscript
func _update_preview():
    if current_portrait_name.is_empty():
        print("警告: portrait_name が空です")
        return
    
    if current_character.character_id.is_empty():
        print("警告: character_id が空です")
        return
    
    print("=== プレビュー更新開始 ===")
    print("ID: ", current_character.character_id)
    print("Expression: ", current_portrait_name)
    
    # クリア
    preview_display.clear_all()
    
    # データ注入
    preview_display.set_character_data_direct(current_character)
    print("データ注入完了")
    
    # 表示
    preview_display.show_character(current_character.character_id, current_portrait_name, 960, 540)
    print("show_character 呼び出し完了")
    
    # 結果確認
    if preview_display.characters.has(current_character.character_id):
        var node = preview_display.characters[current_character.character_id]
        print("ノード作成成功: ", node)
        print("子ノード数: ", node.get_child_count())
        print("表示位置: ", node.position)
    else:
        print("エラー: ノードが作成されませんでした")
```

---

## 次のステップ

上記のデバッグ出力を追加してGodotエディタで実行し、コンソールに何が表示されるか確認してください。

出力内容を教えていただければ、さらに詳細な原因特定ができます。
